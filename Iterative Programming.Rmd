---
title: "Iterative Programming"
author: "Nils Indreiten"
date: "30/03/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Consider trying to get the mean for each column
in a data frame. If the data frame has 4 columns
then a repetitive approach would be to do the
following:

```{r}
means1 = mean(df$x)
means1 = mean(df$y)
means1 = mean(df$z)
means1 = mean(df$w)
```

What would happen if you wanted to do a median 
instead or if the underlying structure of the 
data changed. Any minor change would mean 
the this process would need to be repeated.

# For Loops

A for loop might help us solve the problem above

```{r}
for (column in c('x','y','z','q')){
  mean(df[[column]])
}
```

^^ Creates an iterative process whereby something
will be done for every element. The word column
is arbitrarily used here as a placeholder for 
which of the columns we have at a given point in
the process. On the first iteration, column 
will equal x, on the second y, etc. Below
is an example with the nycflights data:

```{r}
weather <- nycflights13::weather

for (column in c('temp', 'humid', 'wind_speed', 'precip')) {
  print(mean(weather[[column]], na.rm = TRUE))
}
```

If the data name changes, the only thing we have
to change is the name of the columns. We can 
further iterate on this:

```{r}
columns = c('temp', 'humid', 'wind_speed', 'precip')
nyc_means = rep(NA, length(columns))

for (i in seq_along(columns)) {
  column = columns[i]
  nyc_means[i] = mean(weather[[column]], na.rm = TRUE)
  
  # alternative without the initial first step
  # nyc_means[i] = mean(weather[[columns[i]]], na.rm = TRUE)  
}

nyc_means

```

By creating a columns object, if anything changes
about the columns that we want, then that is the 
only line in the code that we need to change. The
i is now a place holder for a number that goes 
from 1 to the length of columns. The empty 
nyc_means object is the length of the columns,
which means each element will eventually be the 
mean of the corresponding column:

```{r}
columns = c('temp', 'humid', 'wind_speed', 'visib', 'pressure')
nyc_means = rep(NA, length(columns))

for (i in seq_along(columns)) {
  nyc_means[i] = mean(weather[[columns[i]]], na.rm = TRUE)
}

nyc_means %>% round(2)
```

# A speed gain

The following also works:

```{r}
columns = c('temp', 'humid', 'wind_speed', 'visib', 'pressure')
nyc_means = numeric()

for (i in seq_along(columns)) {
  nyc_means[i] = mean(weather[[columns[i]]], na.rm = TRUE)
}

nyc_means %>% round(2)
```
Previous version is faster due to memory usage.

# Implicit Looks

## Apply family

## More importantly, the Purr package. It allows
for the apply family approach to the 
tidyverse.  Consider the following. In the 
list we will use the map function to map
the sum function to each element in the list
the same way we would with lapply. 

```{r}
library(tidyverse)
x <- list(1:3,4:6,7:9)

map(x,sum)
```

## Purrr

Purrr allows us to take the apply family approach to
tidyverse. It takes some getting used to. Consider 
the following: 

```{r}
library(tidyverse)
x <- list(1:3,4:6,7:9)
map(x,sum)
```

The purrr function wants a list or vector, i.e. dont
work in the same way as with mutate and summarise 
except in the sense that data.frames are lists:

```{r}
mtcars |> 
  map_df(scale) # map_df() returns a data frame

mtcars |>  
  map_dbl(sum) # Returns a numeric vector of column sums

diamonds |> 
  map_at(
    vars(carat,depth,price),
    function (x)
      as.integer(x>median(x))
  ) |> 
  as_tibble()
```

## Looping with Lists

List objects make it very easy to iterate data 
processing. Consider if we have models with 
increasing complexity, and we wish to easily 
summarise and/or compare them. A list in which
each element is a model object can be created. 
Then we can iteratively apply a function to get 
a measurement value for each of the models:

```{r}
library(mgcv)

mtcars$cyl <- factor(mtcars$cyl)

mod_lm <- lm(mpg ~wt, data= mtcars)

mod_poly <- lm(mpg ~ poly(wt,2), data = mtcars)

mod_inter <- lm(mpg~wt * cyl, data =mtcars)

mod_gam <- gam(mpg~s(wt), data = mtcars)

mod_gam_inter = gam(mpg ~ cyl + s(wt, by = cyl), data = mtcars)

model_list <- list(
  mod_lm = mod_lm,
  mod_poly = mod_poly,
  mod_inter = mod_inter,
  mod_gam = mod_gam,
  mod_gam_inter = mod_gam_inter
)

# lowest wins 
model_list %>% 
  map_dbl(AIC) %>% 
  sort()
```



```{r}
# Highest wins
model_list %>% 
  map_dbl(
    function(x)
      if_else(inherits(x, 'gam'),
              summary(x)$r.sq,
              summary(x)$adj)
  ) %>% 
  sort(decreasing = TRUE)
```

Go one step further and plot the results. First step
is to use pivot_longer to melt the results into
2 columns of model and value, then ggplot the 
results:

```{r}
model_list %>% 
  map_df(
    function(x)
      if_else(inherits(x, 'gam'),
              summary(x)$r.sq,
              summary(x)$adj)
  ) %>% 
 pivot_longer(cols = starts_with('mod'),
               names_to = 'model',
               values_to = "Adj. Rsq") %>% 
  arrange(desc(`Adj. Rsq`)) %>% 
  mutate(model = factor(model, levels = model)) %>% 
  ggplot(aes(model, `Adj. Rsq`))+
  geom_point(aes(color = model), size = 8, show.legend = FALSE)
```

Can also compare AIC:

```{r}
mod_rsq = 
  model_list %>% 
  map_df(
    function(x)
      if_else(
        inherits(x, 'gam'),
        summary(x)$r.sq,
        summary(x)$adj
      )
  ) %>% 
  pivot_longer(cols = starts_with('mod'),
               names_to = 'model',
               values_to = 'Rsq')

mod_aic =
  model_list %>% 
  map_df(AIC) %>%
  pivot_longer(cols = starts_with('mod'),
               names_to = 'model',
               values_to = 'AIC')

left_join(mod_rsq, mod_aic) %>%
  arrange(AIC) %>%
  mutate(model = factor(model, levels = model)) %>%
  pivot_longer(cols = -model, names_to = 'measure', values_to = 'value') %>%
  ggplot(aes(x = model, y = value)) +
  geom_point(aes(color = model), size = 10, show.legend = F) +
  facet_wrap(~ measure, scales = 'free')
```

## List columns  

data.frames are lists, therefore anything can be 
put into a column as we would into a list. Using 
pmap, it can take more than one arguement and 
feed all columns of the data frame. No need to 
worry about the details, the main point is create
a column that is actually a list. The column
will contain a data frame in each entry:

```{r}
mtcars2 <- as.matrix(mtcars)

mtcars2[sample(1:length(mtcars2),50)] = NA

mtcars2 <- data.frame(mtcars2) %>% 
  rownames_to_column(var = 'observation') %>% 
  as_tibble()

mtcars2 %>% 
  head()
```

create a new variable:

```{r}
mtcars2 <- 
  mtcars2 %>% 
  mutate(
    newvar =
      pmap(.,~data.frame(
        N=sum(!is.na(c(...))),
        Missing =  sum(is.na(c(...)))
      )
      
    )
  )
```

Check out the list column:

```{r}
mtcars2
```

Unnest to view the data:
```{r}
mtcars2 %>% 
  unnest(newvar)
```

Not something you really want to do as mutate or 
other approaches would be more efficient. But u get
the point.

## Exercise 1:
# To the following matrix use apply and the sum 
function to get row or col sums of x:

```{r}
x <- matrix(1:9,3,3)
x
apply(x, 2, sum) # Column sum
apply(x,1,sum) # rowise sum
```

## Exercise 2:
# With the following list object x, use lapply and 
sapply and the sum function to get sums of the 
elements. There is no margin to specify for a list
so just supply the list and the sum function:


```{r}
x <- list(1:3,4:10,11:100)
lapply(x,sum) # Returns list
sapply(x,sum) # Returns vector
```

## Exercise 3:
# As in the previous examples use a map function
# to create a data frame of the column means:

```{r}
d <- tibble(
  x=rnorm(100),
  y= rnorm(100,10,2),
  z=rnorm(100,50,10)
)

d %>% 
  map_dfr(mean)
```








